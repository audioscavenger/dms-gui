const dotenv = require('dotenv');
dotenv.config({ path: '/app/config/.dms-gui.env' });
debug = (process.env.DEBUG === 'true') ? true : false;

// JWT SECRET_KEY generated when container starts
SECRET_KEY = process.env.SECRET_KEY;
SECRET_KEY_EXPIRY = '1h';

// const { name, version, description } = require('./package.json');
DMSGUI_VERSION = (process.env.DMSGUI_VERSION.split("v").length == 2) ? process.env.DMSGUI_VERSION.split("v")[1] : process.env.DMSGUI_VERSION;
DMSGUI_DESCRIPTION = process.env.DMSGUI_DESCRIPTION;
HOSTNAME = process.env.HOSTNAME;
NODE_ENV = process.env.NODE_ENV || 'production';
PORT_NODEJS = process.env.PORT_NODEJS || 3001;
TZ = process.env.TZ || 'UTC';

DMSGUI_CONFIG_PATH   = process.env.DMSGUI_CONFIG_PATH || '/app/config';
DB_Accounts   = DMSGUI_CONFIG_PATH + '/db.accounts.json';
DB_Aliases    = DMSGUI_CONFIG_PATH + '/db.aliases.json';
DB_Settings   = DMSGUI_CONFIG_PATH + '/db.settings.json';
DB_Infos      = DMSGUI_CONFIG_PATH + '/db.infos.json';
DB_Logins     = DMSGUI_CONFIG_PATH + '/db.logins.json';
DATABASE      = DMSGUI_CONFIG_PATH + '/dms-gui.sqlite3';

// Docker container name for docker-mailserver
DMS_CONTAINER = (typeof DMS_CONTAINER == "undefined") ? (process.env.DMS_CONTAINER || 'dms') : DMS_CONTAINER;
containers = (typeof containers == "undefined") ? {} : containers;

// doveadm API
DMS_DOVEADM_PORT=8080

// DMS API we inject
DMS_API_KEY = (typeof DMS_API_KEY == "undefined") ? (process.env.DMS_API_KEY || undefined) : DMS_API_KEY;
DMS_API_PORT = (typeof DMS_API_PORT == "undefined") ? (process.env.DMS_API_PORT || 8888) : DMS_API_PORT;

// other DMS stuff
DMS_SETUP_SCRIPT = (typeof DMS_SETUP_SCRIPT == "undefined") ? (process.env.DMS_SETUP_SCRIPT || '/usr/local/bin/setup') : DMS_SETUP_SCRIPT;
DMS_CONFIG_PATH = (typeof DMS_CONFIG_PATH == "undefined") ? (process.env.DMS_CONFIG_PATH || '/tmp/docker-mailserver') : DMS_CONFIG_PATH;
DKIM_SELECTOR_DEFAULT = 'mail';   // that's hardcoded in DMS

DKIM_KEYTYPES = ['rsa','ed25519'];
DKIM_KEYSIZES = ['1024','2048'];
DKIM_KEYTYPE_DEFAULT = 'rsa';
DKIM_KEYSIZE_DEFAULT = 2048;

DMS_OPTIONS   = [
  'TZ',
  'DMS_RELEASE',
  'ENABLE_RSPAMD',
  'ENABLE_XAPIAN',
  'ENABLE_MTA_STS',
  'PERMIT_DOCKER',
  'DOVECOT_MAILBOX_FORMAT',
  'POSTFIX_MAILBOX_SIZE_LIMIT',
];

isMutable = 1;
isImmutable = 0;


/*
  sh: {
    desc: 'python API server launcher - cancelled'
    path: DMSGUI_CONFIG_PATH + '/user-patches-api.sh',
    content:
`# this script is executed on startup

nohup /usr/bin/python3 $(dirname $0)/user-patches-api.py &
`,
  },
*/
userPatchesAPI = {
  py: {
    desc: 'python API server - mount this to /tmp/docker-mailserver/user-patches-api.py',
    path: DMSGUI_CONFIG_PATH + '/user-patches-api.py',
    content:
`#!/usr/bin/python3

import http.server
import socketserver
import subprocess
import json
import os
import datetime

DMS_API_HOST = '0.0.0.0'                                                  # Listen on all available interfaces
DMS_API_PORT = int(os.environ.get('DMS_API_PORT', 8888))          # Port to listen on
DMS_API_KEY = os.environ.get('DMS_API_KEY', 'please-restart-dms') # generated by bms-gui on first start and added into DMS compose
timeout_default = 1                                               # can be superseeded by passed timeout in data
chunkSize = 1024                                                  # max bytes per request sent from dms-gui

def logger(message):
  # 2025-11-05T15:05:49.710284+00:00 mx dms-gui-api:
  print(f'{datetime.datetime.now().astimezone().strftime("%Y-%m-%dT%H:%M:%S.%f%z")} {os.uname().nodename.split(".")[0]} dms-gui-api: {message}')

class APIHandler(http.server.BaseHTTPRequestHandler):

  def do_POST(self):
    # 1. Get the content length from the headers
    content_bearer  = self.headers.get('Authorization', 'missing')
    content_length  = int(self.headers.get('Content-Length', 0))

    # 2. Read the raw POST data from the request body
    post_data = self.rfile.read(content_length)

    # 3. Attempt to parse the data as JSON
    try:
      json_data = json.loads(post_data.decode('utf-8'))
      logger("[dms-gui] API: Received JSON data: {json_data}")
      
      # api_key = json_data.get('api_key')
      command = json_data.get('command')
      timeout = json_data.get('timeout', timeout_default)
      
      # logger("[dms-gui] API: Received API Key: {api_key}")
      # logger("[dms-gui] API: Received command: {command}")
      # logger("[dms-gui] API: Received timeout: {timeout}")
    
      # if api_key == DMS_API_KEY:
      if content_bearer == DMS_API_KEY:
        if not command:
          response_message = {"status": "error", "error": "no command was passed"}
          logger(response_message['error'])
          
        else:
          try:
            # from here we could analyze and limit commands to be executed like remove unlink and rm, etc
            
            logger("[dms-gui] API: Executing command: {command}")
            result = subprocess.run(command, 
                                     shell=True, 
                                     capture_output=True, # Capture stdout and stderr
                                     text=True,           # Decode stdout and stderr as text
                                     check=False,         # Do not raise an exception for non-zero exit codes
                                     timeout=timeout,     # timeout in seconds
                                    )
            # logger("[dms-gui] ddebug: result: {result}")  #  CompletedProcess(args='/usr/local/bin/setup alias list', returncode=0, stdout='...
            
            response_message = {
              "status": "success",
              'returncode': result.returncode,
              'stdout': result.stdout,
              'stderr': result.stderr
            }
            # logger("[dms-gui] ddebug: response_message\n{response_message}")
            

          except Exception as e:
            response_message = {"status": "error", "error": str(e)}
            logger(response_message['error'])
          
      else:
        response_message = {"status": "error", "error": f"Invalid api_key: {str(api_key)}"}
        logger(response_message['error'])

      # 4. Send a successful response
      self.send_response(200)
      self.send_header('Content-type', 'application/json')
      self.end_headers()
      logger("[dms-gui] API: Sending response_message: {response_message}")
      self.wfile.write(json.dumps(response_message).encode('utf-8'))

    except json.JSONDecodeError:
      # 5. Handle invalid JSON
      self.send_response(400) # Bad Request
      self.send_header('Content-type', 'application/json')
      self.end_headers()
      response_message = {"status": "error", "message": "Invalid JSON format"}
      self.wfile.write(json.dumps(response_message).encode('utf-8'))

    except Exception as e:
      # 6. Handle other potential errors
      self.send_response(500) # Internal Server Error
      self.send_header('Content-type', 'application/json')
      self.end_headers()
      response_message = {"status": "error", "message": str(e)}
      self.wfile.write(json.dumps(response_message).encode('utf-8'))


with socketserver.TCPServer((DMS_API_HOST, DMS_API_PORT), APIHandler) as httpd:
  logger("[dms-gui] API: Serving at port {DMS_API_HOST}:{DMS_API_PORT}")
  httpd.serve_forever()
`,
  },
  cron: {
    desc: 'https://github.com/orgs/docker-mailserver/discussions/2908 - mount this to /etc/supervisor/conf.d/user-patches-api.conf',
    path: DMSGUI_CONFIG_PATH + '/user-patches-api.conf',
    content:
`
[program:user-patches-api]
startsecs=0
stopwaitsecs=55
autostart=true
autorestart=true
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
command=/usr/bin/python3 /tmp/docker-mailserver/dms-gui/user-patches-api.py
`,
  },
}


// https://github.com/orgs/docker-mailserver/discussions/2908
// Much better to just use a supervisord service config like I had shown over a month ago:

// /etc/supervisor/conf.d/dms-api.conf:

// [program:dms-api]
// startsecs=0
// stopwaitsecs=55
// autostart=true
// autorestart=true
// stdout_logfile=/var/log/supervisor/%(program_name)s.log
// stderr_logfile=/var/log/supervisor/%(program_name)s.log
// command=/usr/bin/python3 /tmp/docker-mailserver/user-patches-api.py



// all undeclared variable are exported as is
// module.exports={
  // debug,
  // DMSGUI_VERSION,
  // DMSGUI_DESCRIPTION,
  // HOSTNAME,
  // NODE_ENV,
  // PORT_NODEJS,
  // TZ,
  // DMS_CONTAINER,
  // DMSGUI_CONFIG_PATH,
  // DB_Accounts,
  // DB_Aliases,
  // DB_Settings,
  // DB_Infos,
  // DB_Logins,
  // DATABASE,
// }

